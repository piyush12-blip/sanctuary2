<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Organimo R&D - The Descent (Awwwards Edition)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,600&family=Space+Grotesk:wght@400;700&display=swap"
    rel="stylesheet">
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      background: transparent; /* PERFECT FIX: Curtain is lifted! */
      color: #ffffff;
      font-family: 'Space Grotesk', sans-serif;
      overflow-x: hidden;
      width: 100%;
      cursor: none;
    }

    #cursor-dot,
    #cursor-ring {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10000;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      will-change: transform, width, height;
    }

    #cursor-dot {
      width: 6px;
      height: 6px;
      background-color: #fff;
      mix-blend-mode: exclusion;
    }

    #cursor-ring {
      width: 40px;
      height: 40px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      transition: border-color 0.3s ease;
    }

    .magnetic {
      display: inline-block;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
    }

    #header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 2.5rem;
      display: flex;
      justify-content: space-between;
      box-sizing: border-box;
      mix-blend-mode: exclusion;
      z-index: 100;
      pointer-events: none;
    }

    .logo {
      font-family: 'Playfair Display', serif;
      font-style: italic;
      font-size: 1.8rem;
      letter-spacing: 1px;
      pointer-events: auto;
      cursor: none;
    }

    .nav {
      font-size: 1rem;
      letter-spacing: 4px;
      text-transform: uppercase;
      pointer-events: auto;
      cursor: none;
    }

    #scroll-container {
      height: 500vh;
      width: 100vw;
      position: relative;
    }

    .story-text {
      position: fixed;
      left: 10vw;
      top: 50vh;
      transform: translateY(-50%);
      max-width: 500px;
      pointer-events: none;
      mix-blend-mode: exclusion;
    }

    .split-word {
      display: inline-block;
      overflow: hidden;
      vertical-align: top;
    }

    .split-char {
      display: inline-block;
      transform: translateY(110%);
      will-change: transform;
    }

    h1 {
      font-family: 'Playfair Display', serif;
      font-size: 4rem;
      font-style: italic;
      margin: 0 0 1rem 0;
      letter-spacing: 1px;
      font-weight: 600;
      line-height: 1.1;
    }

    p {
      font-size: 1.2rem;
      line-height: 1.6;
      margin: 0;
      opacity: 0.8;
      font-weight: 400;
    }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 999;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1.5rem;
      letter-spacing: 4px;
      transition: opacity 1s ease;
      cursor: none;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2.5rem;
      }

      .story-text {
        left: 5vw;
        right: 5vw;
        max-width: none;
        text-align: center !important;
      }

      #cursor-dot,
      #cursor-ring {
        display: none;
      }
    }
  </style>
</head>

<body>

  <div id="cursor-dot"></div>
  <div id="cursor-ring"></div>

  <div id="loading">LOADING EXPERIENCE...</div>

  <header id="header">
    <div class="logo magnetic">Organimo R&D</div>
    <div class="nav magnetic">The Descent</div>
  </header>

  <div id="scroll-container">
    <div class="story-text text-block" id="text-1">
      <h1 class="split-target">The Architecture</h1>
      <p class="split-target">Descending into the procedural depths of the digital environment.</p>
    </div>
    <div class="story-text text-block" id="text-2" style="left: auto; right: 10vw; text-align: right;">
      <h1 class="split-target">Fluid Memory</h1>
      <p class="split-target">Artifacts of the past float through the synthetic atmosphere, bending as you pass.</p>
    </div>
    <div class="story-text text-block" id="text-3">
      <h1 class="split-target">The Deep</h1>
      <p class="split-target">A seamless ocean of simulated mathematical noise reacting to physical presence.</p>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "gsap": "https://unpkg.com/gsap@3.12.5/index.js",
      "gsap/ScrollTrigger": "https://unpkg.com/gsap@3.12.5/ScrollTrigger.js",
      "@studio-freight/lenis": "https://unpkg.com/@studio-freight/lenis@1.0.42/dist/lenis.mjs"
    }
  }
</script>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
    import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
    import gsap from 'gsap';
    import ScrollTrigger from 'gsap/ScrollTrigger';
    import Lenis from '@studio-freight/lenis';

    gsap.registerPlugin(ScrollTrigger);

    //=========================================
    // 0. Performance & Device Detection
    //=========================================
    const isMobile = window.innerWidth <= 768 || /Mobi|Android/i.test(navigator.userAgent);
    const pixelRatio = Math.min(window.devicePixelRatio, 0.75); // Hard cap pixel ratio
    const oceanSegmentCount = isMobile ? 64 : 128;

    //=========================================
    // 1. Text Splitting Utility (Typography)
    //=========================================
    function splitText(element) {
      const text = element.innerText;
      element.innerHTML = '';
      const words = text.split(' ');
      words.forEach((word, wordIndex) => {
        const wordSpan = document.createElement('span');
        wordSpan.classList.add('split-word');
        word.split('').forEach((char) => {
          const charSpan = document.createElement('span');
          charSpan.classList.add('split-char');
          charSpan.innerHTML = char === ' ' ? '&nbsp;' : char;
          wordSpan.appendChild(charSpan);
        });
        element.appendChild(wordSpan);
        if (wordIndex < words.length - 1) {
          const space = document.createElement('span');
          space.classList.add('split-word');
          space.innerHTML = '&nbsp;';
          element.appendChild(space);
        }
      });
      return element.querySelectorAll('.split-char');
    }

    const textBlocksChunks = [];
    document.querySelectorAll('.text-block').forEach(block => {
      const targets = block.querySelectorAll('.split-target');
      let allChars = [];
      targets.forEach(t => {
        const chars = splitText(t);
        allChars = [...allChars, ...chars];
      });
      textBlocksChunks.push(allChars);
    });

    //=========================================
    // 2. Custom Magnetic Cursor
    //=========================================
    const cursorDot = document.getElementById('cursor-dot');
    const cursorRing = document.getElementById('cursor-ring');
    let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, vX: 0, vY: 0 };
    let cPos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let isHovering = false;
    let lastMouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

    if (!isMobile) {
      window.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      document.querySelectorAll('.magnetic').forEach(el => {
        el.addEventListener('mouseenter', () => { isHovering = true; cursorRing.style.borderColor = '#ff0077'; });
        el.addEventListener('mouseleave', () => { isHovering = false; cursorRing.style.borderColor = 'rgba(255,255,255,0.4)'; });
      });
    }

    //=========================================
    // 3. Core Three.js Setups
    //=========================================
    const lenis = new Lenis({
      smoothWheel: true,
      duration: 1.5,
      easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t))
    });

    lenis.on('scroll', ScrollTrigger.update);
    gsap.ticker.add((time) => {
      lenis.raf(time * 1000);
      updateCursor();
    });
    gsap.ticker.lagSmoothing(0);

    function updateCursor() {
      if (isMobile) return;

      mouse.vX = mouse.x - lastMouse.x;
      mouse.vY = mouse.y - lastMouse.y;
      lastMouse.x = mouse.x;
      lastMouse.y = mouse.y;

      const velocity = Math.sqrt(mouse.vX * mouse.vX + mouse.vY * mouse.vY);
      const stretch = Math.min(velocity * 0.5, 20);
      const angle = Math.atan2(mouse.vY, mouse.vX) * 180 / Math.PI;

      cPos.x += (mouse.x - cPos.x) * 0.15;
      cPos.y += (mouse.y - cPos.y) * 0.15;

      cursorDot.style.transform = `translate(-50%, -50%) translate(${mouse.x}px, ${mouse.y}px)`;
      let ringSize = isHovering ? 60 : 40;
      cursorRing.style.width = `${ringSize + stretch}px`;
      cursorRing.style.height = `${ringSize - stretch * 0.2}px`;
      cursorRing.style.transform = `translate(-50%, -50%) translate(${cPos.x}px, ${cPos.y}px) rotate(${angle}deg)`;
    }

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.025);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 20, 40);
    camera.rotation.set(-Math.PI / 8, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(pixelRatio);
    document.body.appendChild(renderer.domElement);

    //=========================================
    // 4. Background: Volumetric Raymarched Clouds (FBM)
    //=========================================
    const bgGeometry = new THREE.BufferGeometry();
    const bgVertices = new Float32Array([-1.0, -1.0, 0.0, 3.0, -1.0, 0.0, -1.0, 3.0, 0.0]);
    const bgUvs = new Float32Array([0.0, 0.0, 2.0, 0.0, 0.0, 2.0]);
    bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgVertices, 3));
    bgGeometry.setAttribute('uv', new THREE.BufferAttribute(bgUvs, 2));

    const bgUniforms = {
      uTime: { value: 0 },
      uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      uBgColor: { value: new THREE.Color(0x000000) } // <-- FIXED: Links color logic to the shader!
    };

    const bgMaterial = new THREE.ShaderMaterial({
      uniforms: bgUniforms,
      vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `,
      fragmentShader: `
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec3 uBgColor; // <-- FIXED
            varying vec2 vUv;

            vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
            vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
            float snoise(vec3 v){ 
              const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
              const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
              vec3 i  = floor(v + dot(v, C.yyy) );
              vec3 x0 = v - i + dot(i, C.xxx) ;
              vec3 g = step(x0.yzx, x0.xyz);
              vec3 l = 1.0 - g;
              vec3 i1 = min( g.xyz, l.zxy );
              vec3 i2 = max( g.xyz, l.zxy );
              vec3 x1 = x0 - i1 + 1.0 * C.xxx;
              vec3 x2 = x0 - i2 + 2.0 * C.xxx;
              vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;
              i = mod(i, 289.0 ); 
              vec4 p = permute( permute( permute( 
                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                       + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                       + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
              float n_ = 1.0/7.0;
              vec3  ns = n_ * D.wyz - D.xzx;
              vec4 j = p - 49.0 * floor(p * ns.z *ns.z);
              vec4 x_ = floor(j * ns.z);
              vec4 y_ = floor(j - 7.0 * x_ );
              vec4 x = x_ *ns.x + ns.yyyy;
              vec4 y = y_ *ns.x + ns.yyyy;
              vec4 h = 1.0 - abs(x) - abs(y);
              vec4 b0 = vec4( x.xy, y.xy );
              vec4 b1 = vec4( x.zw, y.zw );
              vec4 s0 = floor(b0)*2.0 + 1.0;
              vec4 s1 = floor(b1)*2.0 + 1.0;
              vec4 sh = -step(h, vec4(0.0));
              vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
              vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
              vec3 p0 = vec3(a0.xy,h.x);
              vec3 p1 = vec3(a0.zw,h.y);
              vec3 p2 = vec3(a1.xy,h.z);
              vec3 p3 = vec3(a1.zw,h.w);
              vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
              p0 *= norm.x;  p1 *= norm.y;  p2 *= norm.z;  p3 *= norm.w;
              vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
              m = m * m;
              return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            float fbm(vec3 p) {
                float sum = 0.0;
                float amp = 1.0;
                float freq = 1.0;
                for(int i = 0; i < 3; i++) {
                    sum += snoise(p * freq) * amp;
                    amp *= 0.5;
                    freq *= 2.0;
                }
                return sum;
            }

            vec4 raymarch(vec3 ro, vec3 rd) {
                float density = 0.0;
                vec3 col = vec3(0.0);
                
                float t = 0.0;
                for(int i = 0; i < 15; i++) {
                    vec3 p = ro + rd * t;
                    vec3 dp = p;
                    dp.z -= uTime * 0.2; 
                    
                    float n = fbm(dp * 0.4);
                    float d = smoothstep(0.0, 1.0, -abs(p.z) + 1.2 + n * 2.5);
                    d = max(0.0, d);
                    
                    if(d > 0.01) {
                        float alpha = (1.0 - density) * d * 0.15;
                        density += alpha;
                        
                        vec3 purple = vec3(0.44, 0.0, 1.0);
                        vec3 pink   = vec3(1.0, 0.0, 0.46);
                        vec3 localCol = mix(purple, pink, smoothstep(-0.5, 0.5, n));
                        
                        col += localCol * alpha * 0.5; 
                    }
                    
                    t += 0.2 + d * 0.1; 
                    if(density > 0.99 || t > 12.0) break;
                }
                return vec4(col, density);
            }

            void main() {
                vec2 uv = (vUv - 0.5) * 2.0;
                uv.x *= uResolution.x / uResolution.y;
                
                vec3 ro = vec3(0.0, 0.0, 4.0);
                vec3 rd = normalize(vec3(uv, -1.0));
                
                vec4 bgCol = vec4(uBgColor, 1.0); // <-- FIXED
                vec4 res = raymarch(ro, rd);
                
                vec3 finalCol = mix(bgCol.rgb, res.rgb, res.a);
                gl_FragColor = vec4(finalCol, 1.0);
            }
        `,
      depthWrite: false,
      depthTest: false,
      transparent: true
    });

    const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
    bgMesh.frustumCulled = false;
    bgMesh.renderOrder = -100;
    scene.add(bgMesh);

    //=========================================
    // 5. Light setup
    //=========================================
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0x7000ff, 2.0);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    const oceanLight = new THREE.PointLight(0x0033ff, 5.0, 100);
    oceanLight.position.set(0, -10, -50);
    scene.add(oceanLight);

    const imageLight = new THREE.SpotLight(0xff0077, 10.0, 50, Math.PI / 4, 0.5, 1);
    imageLight.position.set(0, 5, 0);
    imageLight.target.position.set(0, -10, -20);
    scene.add(imageLight);
    scene.add(imageLight.target);

    //=========================================
    // 6. Phase 1 & 2 & 3 Procedural 3D Assets 
    //=========================================

    // Phase 1: The Peak (Rock & Jar)
    const phase1Group = new THREE.Group();
    scene.add(phase1Group);

    // Procedural Rock Core
    const rockGeo = new THREE.IcosahedronGeometry(12, 4);
    const rockMat = new THREE.MeshStandardMaterial({
      color: 0x111111,
      roughness: 0.9,
      metalness: 0.1,
      flatShading: true
    });

    const pos = rockGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      let v = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i));
      v.normalize().multiplyScalar(12 + Math.random() * 2);
      pos.setXYZ(i, v.x, v.y, v.z);
    }
    rockGeo.computeVertexNormals();

    const rock = new THREE.Mesh(rockGeo, rockMat);
    phase1Group.add(rock);

    // Placeholder Product Jar
    const jarGeo = new THREE.CylinderGeometry(2, 2, 6, 32);
    const jarMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      roughness: 0.1,
      metalness: 0.9,
      clearcoat: 1.0
    });
    const jar = new THREE.Mesh(jarGeo, jarMat);
    jar.position.y = 15;
    phase1Group.add(jar);

    // Phase 2: The Surreal Surface (Floating Shapes)
    const phase2Group = new THREE.Group();
    scene.add(phase2Group);

    const matPhase2 = new THREE.MeshStandardMaterial({ color: 0xff0077, roughness: 0.4, metalness: 0.8 });

    // Torus (Shell)
    const shape1 = new THREE.Mesh(new THREE.TorusGeometry(3, 1, 16, 100), matPhase2);
    shape1.position.set(-15, -15, -30);
    shape1.rotation.x = Math.PI / 2;
    phase2Group.add(shape1);

    // Cone (Fish)
    const shape2 = new THREE.Mesh(new THREE.ConeGeometry(3, 8, 32), new THREE.MeshStandardMaterial({ color: 0x00aaff, roughness: 0.2, metalness: 0.5 }));
    shape2.position.set(15, -18, -40);
    shape2.rotation.z = Math.PI / 4;
    phase2Group.add(shape2);

    // Cylinder (Pillar)
    const shape3 = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 10, 32), new THREE.MeshStandardMaterial({ color: 0x7000ff, roughness: 0.5, metalness: 0.2 }));
    shape3.position.set(0, -20, -50);
    shape3.rotation.x = Math.PI / 4;
    phase2Group.add(shape3);

    const phase2Shapes = [shape1, shape2, shape3];

    // Phase 3: The Deep Trench (Walls, Bubbles, UI Spheres)
    const phase3Group = new THREE.Group();
    scene.add(phase3Group);

    // Trench Walls
    const wallGeo = new THREE.PlaneGeometry(50, 200, 32, 64);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 1.0, wireframe: isMobile });

    const wallPos = wallGeo.attributes.position;
    for (let i = 0; i < wallPos.count; i++) {
      wallPos.setZ(i, Math.random() * 8);
    }
    wallGeo.computeVertexNormals();

    const leftWall = new THREE.Mesh(wallGeo, wallMat);
    leftWall.position.set(-25, -100, -80);
    leftWall.rotation.y = Math.PI / 2;
    phase3Group.add(leftWall);

    const rightWall = new THREE.Mesh(wallGeo, wallMat);
    rightWall.position.set(25, -100, -80);
    rightWall.rotation.y = -Math.PI / 2;
    phase3Group.add(rightWall);

    // Bubble Particles
    const bubbleGeo = new THREE.BufferGeometry();
    const bubbleCount = 200;
    const bubblePos = new Float32Array(bubbleCount * 3);
    for (let i = 0; i < bubbleCount * 3; i++) {
      bubblePos[i] = (Math.random() - 0.5) * 40; 
    }
    bubbleGeo.setAttribute('position', new THREE.BufferAttribute(bubblePos, 3));
    const bubbleMat = new THREE.PointsMaterial({ color: 0xaaaaff, size: 0.5, transparent: true, opacity: 0.6 });
    const bubbles = new THREE.Points(bubbleGeo, bubbleMat);
    bubbles.position.set(0, -100, -80);
    phase3Group.add(bubbles);

    // 3 Refractive Glass UI Spheres
    const glassMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      transmission: 1.0,
      opacity: 1.0,
      metalness: 0,
      roughness: 0.1,
      ior: 1.5,
      thickness: 0.5,
      specularIntensity: 1.0
    });

    const sphereGeo = new THREE.SphereGeometry(4, 32, 32);
    const uiSpheres = [];

    for (let i = 0; i < 3; i++) {
      const sphere = new THREE.Mesh(sphereGeo, glassMat);
      sphere.position.set((i - 1) * 12, -70 - (i * 30), -80);

      const innerGeo = i === 0 ? new THREE.BoxGeometry(2, 2, 2) : i === 1 ? new THREE.TorusGeometry(1.5, 0.4, 16, 32) : new THREE.TetrahedronGeometry(2);
      const innerMat = new THREE.MeshBasicMaterial({ color: i === 0 ? 0xff0077 : i === 1 ? 0x00aaff : 0x7000ff });
      const innerShape = new THREE.Mesh(innerGeo, innerMat);
      sphere.add(innerShape);

      phase3Group.add(sphere);
      uiSpheres.push(sphere);
    }

    //=========================================
    // 7. Asset Compression Pipeline (DRACO & KTX2)
    //=========================================
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/gltf/');

    const ktx2Loader = new KTX2Loader();
    ktx2Loader.setTranscoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/');
    ktx2Loader.detectSupport(renderer);

    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);
    gltfLoader.setKTX2Loader(ktx2Loader);

    function hideLoading() {
      const loaderUi = document.getElementById('loading');
      if (loaderUi) {
        loaderUi.style.opacity = 0;
        setTimeout(() => loaderUi.remove(), 1000);
      }
    }
    setTimeout(hideLoading, 500);

    //=========================================
    // 8. GPGPU / FBO Physics for Ocean Ripples
    //=========================================
    const fboSize = 128;
    const gpuCompute = new GPUComputationRenderer(fboSize, fboSize, renderer);
    if (isMobile) gpuCompute.setDataType(THREE.HalfFloatType);

    const heightmap0 = gpuCompute.createTexture();
    fillTexture(heightmap0);

    const heightmapShader = `
        uniform vec2 mousePos;
        uniform float mouseSize;
        uniform float viscViscosity;

        void main() {
            vec2 uv = gl_FragCoord.xy / resolution.xy;
            
            vec2 texelSize = 1.0 / resolution.xy;
            
            float x0 = texture2D(heightmap, uv - vec2(texelSize.x, 0.0)).r;
            float x1 = texture2D(heightmap, uv + vec2(texelSize.x, 0.0)).r;
            float y0 = texture2D(heightmap, uv - vec2(0.0, texelSize.y)).r;
            float y1 = texture2D(heightmap, uv + vec2(0.0, texelSize.y)).r;
            
            vec4 currentState = texture2D(heightmap, uv);
            float currentHeight = currentState.r;
            float previousHeight = currentState.g; 
            
            float newHeight = ((x0 + x1 + y0 + y1) * 0.5) - previousHeight;
            newHeight *= 0.99; 
            
            float dist = distance(uv, mousePos);
            if(dist < mouseSize) {
                newHeight += (mouseSize - dist) * 0.1; 
            }
            
            gl_FragColor = vec4(newHeight, currentHeight, 0.0, 1.0);
        }
    `;

    const heightmapVariable = gpuCompute.addVariable("heightmap", heightmapShader, heightmap0);
    gpuCompute.setVariableDependencies(heightmapVariable, [heightmapVariable]);

    heightmapVariable.material.uniforms.mousePos = { value: new THREE.Vector2(-1, -1) };
    heightmapVariable.material.uniforms.mouseSize = { value: 0.03 };

    const error = gpuCompute.init();
    if (error !== null) console.error(error);

    function fillTexture(texture) {
      const pixels = texture.image.data;
      for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 0; pixels[i + 1] = 0; pixels[i + 2] = 0; pixels[i + 3] = 1;
      }
    }

    const raycaster = new THREE.Raycaster();
    const mouseContext = new THREE.Vector2(-1, -1);

    const oceanGeo = new THREE.PlaneGeometry(150, 150, oceanSegmentCount, oceanSegmentCount);
    oceanGeo.rotateX(-Math.PI / 2);

    const oceanUniforms = {
      uHeightmap: { value: null },
      uColorDeep: { value: new THREE.Color('#000000') }, 
      uColorShallow: { value: new THREE.Color('#3300aa') },
      uTime: { value: 0 }
    };

    const oceanMat = new THREE.ShaderMaterial({
      uniforms: oceanUniforms,
      vertexShader: `
            uniform sampler2D uHeightmap;
            uniform float uTime;
            varying float vElevation;

            void main() {
                vec2 simUv = uv; 
                vec4 heightData = texture2D(uHeightmap, simUv);
                
                float elevation = heightData.r * 15.0; 
                
                elevation += sin(position.x * 0.05 + uTime * 0.5) * sin(position.z * 0.05 + uTime * 0.5) * 1.5;

                vec3 newPosition = position;
                newPosition.y += elevation;
                vElevation = elevation;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `,
      fragmentShader: `
            uniform vec3 uColorDeep;
            uniform vec3 uColorShallow;
            varying float vElevation;

            void main() {
                float mixStrength = (vElevation + 1.0) * 0.3; 
                mixStrength = clamp(mixStrength, 0.0, 1.0);
                
                vec3 color = mix(uColorDeep, uColorShallow, mixStrength);
                gl_FragColor = vec4(color, 1.0);
            }
        `,
    });

    const ocean = new THREE.Mesh(oceanGeo, oceanMat);
    ocean.position.set(0, -10, -60);
    scene.add(ocean);

    const interactionPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(150, 150),
      new THREE.MeshBasicMaterial({ visible: false })
    );
    interactionPlane.rotation.x = -Math.PI / 2;
    interactionPlane.position.copy(ocean.position);
    scene.add(interactionPlane);

    if (!isMobile) {
      window.addEventListener('mousemove', (e) => {
        mouseContext.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouseContext.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });
    }

    //=========================================
    // 9. Post-Processing Context (FIXED!)
    //=========================================
    const godRayUniforms = {
      tDiffuse: { value: null },
      uTime: { value: 0 },
      uColor: { value: new THREE.Color(0x7000ff) },
      uIntensity: { value: 0.0 }
    };

    const godRayPass = new ShaderPass({
      uniforms: godRayUniforms,
      vertexShader: `
            varying vec2 vUv;
            void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
        `,
      fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform float uTime;
            uniform vec3 uColor;
            uniform float uIntensity;
            varying vec2 vUv;
            
            void main() {
                vec4 texel = texture2D(tDiffuse, vUv);
                
                float ray = sin(vUv.x * 20.0 + uTime) * sin(vUv.x * 10.0 - uTime * 0.5) * 0.5 + 0.5;
                float fade = smoothstep(0.0, 1.0, vUv.y); 
                
                vec3 finalColor = texel.rgb + uColor * ray * fade * uIntensity;
                gl_FragColor = vec4(finalColor, texel.a);
            }
        `
    });

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    composer.addPass(godRayPass); 

    //=========================================
    // 10. GSAP ScrollTrigger Master Journey 
    //=========================================
    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: "#scroll-container",
        start: "top top",
        end: "bottom bottom",
        scrub: 1.5
      }
    });

    const colorTarget = { fogColor: new THREE.Color(0x000000), bgColor: new THREE.Color(0x000000) };

    // --- PHASE 1: The Peak (0% - 30%) ---
    tl.to(camera.position, { x: 20, y: 15, z: 20, ease: "power1.inOut" }, 0.0);
    tl.to(camera.rotation, { y: Math.PI / 4, ease: "power1.inOut" }, 0.0);
    tl.to(camera.position, { x: 0, y: -5, z: -10, ease: "power2.in" }, 0.15);
    tl.to(camera.rotation, { x: 0, y: 0, ease: "power2.in" }, 0.15);

    // --- PHASE 2: The Surreal Surface (30% - 60%) ---
    tl.to(camera.position, { x: 0, y: -5, z: -40, ease: "none" }, 0.3);

    // --- PHASE 3: The Deep Trench (60% - 100%) ---
    tl.to(camera.position, { x: 0, y: -180, z: -80, ease: "power2.inOut" }, 0.6);
    tl.to(camera.rotation, { x: Math.PI / 6, ease: "power1.inOut" }, 0.6);

    // Animate Colors (Fog and BG) to deep purple
    tl.to(colorTarget.fogColor, {
      r: 0.1, g: 0.0, b: 0.3,
      onUpdate: () => scene.fog.color.copy(colorTarget.fogColor), ease: "power1.inOut"
    }, 0.6);
    tl.to(colorTarget.bgColor, {
      r: 0.05, g: 0.0, b: 0.15,
      ease: "power1.inOut"
    }, 0.6);

    tl.to(godRayUniforms.uIntensity, { value: 1.0, ease: "power1.inOut" }, 0.6);

    // Staggered Text
    gsap.to(textBlocksChunks[0], {
      y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out',
      scrollTrigger: { trigger: "#scroll-container", start: "1% top", end: "10% top", scrub: 1 }
    });
    tl.to(document.getElementById('text-1'), { opacity: 0, duration: 0.1 }, 0.2);

    document.getElementById('text-2').style.opacity = 1;
    gsap.fromTo(textBlocksChunks[1], { y: '110%' }, {
      y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out',
      scrollTrigger: { trigger: "#scroll-container", start: "30% top", end: "40% top", scrub: 1 }
    });
    tl.to(document.getElementById('text-2'), { opacity: 0, duration: 0.1 }, 0.6);

    document.getElementById('text-3').style.opacity = 1;
    gsap.fromTo(textBlocksChunks[2], { y: '110%' }, {
      y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out',
      scrollTrigger: { trigger: "#scroll-container", start: "70% top", end: "85% top", scrub: 1 }
    });

    //=========================================
    // 11. Render Loop
    //=========================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight); 
    });

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const elapsedTime = clock.getElapsedTime();

      // Cloud Logic
      bgUniforms.uTime.value = elapsedTime;
      bgUniforms.uBgColor.value.copy(colorTarget.bgColor); // FIXED: Activates deep sea purple!

      // Phase 2 Shapes Animation (Bobbing)
      phase2Shapes.forEach((shape, i) => {
        shape.position.y += Math.sin(elapsedTime * 2.0 + i) * 0.02;
        shape.rotation.x += 0.005;
        shape.rotation.y += 0.005;
      });

      // 1. Physics Raycasting
      if (camera.position.z < -20 && !isMobile) {
        raycaster.setFromCamera(mouseContext, camera);
        const intersects = raycaster.intersectObject(interactionPlane);
        if (intersects.length > 0) {
          heightmapVariable.material.uniforms.mousePos.value.set(intersects[0].uv.x, intersects[0].uv.y);
        } else {
          heightmapVariable.material.uniforms.mousePos.value.set(-1, -1);
        }
      } else {
        heightmapVariable.material.uniforms.mousePos.value.set(-1, -1);
      }

      // 2. Compute FBO Physics
      gpuCompute.compute();

      // 3. Feed result back to Ocean Shader
      oceanUniforms.uHeightmap.value = gpuCompute.getCurrentRenderTarget(heightmapVariable).texture;
      oceanUniforms.uTime.value = elapsedTime;

      // Phase 3 Under Water Animations
      const bubblePositions = bubbles.geometry.attributes.position.array;
      for (let i = 1; i < bubbleCount * 3; i += 3) {
        bubblePositions[i] += 0.1; 
        if (bubblePositions[i] > 100) bubblePositions[i] = -100; 
      }
      bubbles.geometry.attributes.position.needsUpdate = true;

      uiSpheres.forEach((sphere, i) => {
        sphere.rotation.y += 0.01;
        sphere.children[0].rotation.x += 0.02; 
        sphere.children[0].rotation.y += 0.02;
      });

      // Update God Rays time
      if (composer) {
        godRayUniforms.uTime.value = elapsedTime;
      }

      // 5. Render Scene through Composer
      composer.render();
    }

    animate();
  </script>

</body>

</html>
