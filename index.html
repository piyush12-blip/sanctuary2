<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Organimo R&D - The Descent (Awwwards Edition)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,600&family=Space+Grotesk:wght@400;700&display=swap"
    rel="stylesheet">
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      background: transparent; /* FIXED: The black curtain is lifted! */
      color: #ffffff;
      font-family: 'Space Grotesk', sans-serif;
      overflow-x: hidden;
      width: 100%;
      cursor: none;
    }

    #cursor-dot,
    #cursor-ring {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10000;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      will-change: transform, width, height;
    }

    #cursor-dot {
      width: 6px;
      height: 6px;
      background-color: #fff;
      mix-blend-mode: exclusion;
    }

    #cursor-ring {
      width: 40px;
      height: 40px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      transition: border-color 0.3s ease;
    }

    .magnetic {
      display: inline-block;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
    }

    #header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 2.5rem;
      display: flex;
      justify-content: space-between;
      box-sizing: border-box;
      mix-blend-mode: exclusion;
      z-index: 100;
      pointer-events: none;
    }

    .logo {
      font-family: 'Playfair Display', serif;
      font-style: italic;
      font-size: 1.8rem;
      letter-spacing: 1px;
      pointer-events: auto;
      cursor: none;
    }

    .nav {
      font-size: 1rem;
      letter-spacing: 4px;
      text-transform: uppercase;
      pointer-events: auto;
      cursor: none;
    }

    #scroll-container {
      height: 1200vh;
      width: 100vw;
      position: relative;
    }

    .story-text {
      position: fixed;
      left: 10vw;
      top: 50vh;
      transform: translateY(-50%);
      max-width: 500px;
      pointer-events: none;
      mix-blend-mode: exclusion;
    }

    .split-word {
      display: inline-block;
      overflow: hidden;
      vertical-align: top;
    }

    .split-char {
      display: inline-block;
      transform: translateY(110%);
      will-change: transform;
    }

    h1 {
      font-family: 'Playfair Display', serif;
      font-size: 4rem;
      font-style: italic;
      margin: 0 0 1rem 0;
      letter-spacing: 1px;
      font-weight: 600;
      line-height: 1.1;
    }

    p {
      font-size: 1.2rem;
      line-height: 1.6;
      margin: 0;
      opacity: 0.8;
      font-weight: 400;
    }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 999;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1.5rem;
      letter-spacing: 4px;
      transition: opacity 1s ease;
      cursor: none;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2.5rem;
      }

      .story-text {
        left: 5vw;
        right: 5vw;
        max-width: none;
        text-align: center !important;
      }

      #cursor-dot,
      #cursor-ring {
        display: none;
      }
    }
  </style>
</head>

<body>

  <div id="cursor-dot"></div>
  <div id="cursor-ring"></div>

  <div id="loading">LOADING EXPERIENCE...</div>

  <header id="header">
    <div class="logo magnetic">Organimo R&D</div>
    <div class="nav magnetic">The Descent</div>
  </header>

  <div id="scroll-container">
    <div class="story-text text-block" id="text-1">
      <h1 class="split-target">The Galactic Peak</h1>
      <p class="split-target">A monolithic origin in a sea of lavender mist and starlight.</p>
    </div>
    <div class="story-text text-block" id="text-2" style="left: auto; right: 10vw; text-align: right;">
      <h1 class="split-target">The Spiral Descent</h1>
      <p class="split-target">Floating isles and golden swimmers glint in the sunset.</p>
    </div>
    <div class="story-text text-block" id="text-3">
      <h1 class="split-target">The Sacred Shell</h1>
      <p class="split-target">Pink coral and a glowing pearl wait at the water's surface.</p>
    </div>
    <div class="story-text text-block" id="text-4" style="left: auto; right: 10vw; text-align: right;">
      <h1 class="split-target">The Marine Garden</h1>
      <p class="split-target">Dense aquatic life thrives where the light meets the water.</p>
    </div>
    <div class="story-text text-block" id="text-5">
      <h1 class="split-target">Deep Reef</h1>
      <p class="split-target">Dark obelisks and purple god rays pierce the abyssal depths.</p>
    </div>
    <div class="story-text text-block" id="text-6" style="left: auto; right: 10vw; text-align: right; bottom: 5vh; top: auto; transform: none;">
      <h1 class="split-target">The Golden Pyramid</h1>
      <p class="split-target">A glowing geometric artifact resting on the quiet seafloor.</p>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "gsap": "https://unpkg.com/gsap@3.12.5/index.js",
      "gsap/ScrollTrigger": "https://unpkg.com/gsap@3.12.5/ScrollTrigger.js",
      "@studio-freight/lenis": "https://unpkg.com/@studio-freight/lenis@1.0.42/dist/lenis.mjs"
    }
  }
</script>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
    import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
    import gsap from 'gsap';
    import ScrollTrigger from 'gsap/ScrollTrigger';
    import Lenis from '@studio-freight/lenis';

    gsap.registerPlugin(ScrollTrigger);

    const isMobile = window.innerWidth <= 768 || /Mobi|Android/i.test(navigator.userAgent);
    const pixelRatio = Math.min(window.devicePixelRatio, 0.75); 
    const oceanSegmentCount = isMobile ? 64 : 128;

    function splitText(element) {
      const text = element.innerText;
      element.innerHTML = '';
      const words = text.split(' ');
      words.forEach((word, wordIndex) => {
        const wordSpan = document.createElement('span');
        wordSpan.classList.add('split-word');
        word.split('').forEach((char) => {
          const charSpan = document.createElement('span');
          charSpan.classList.add('split-char');
          charSpan.innerHTML = char === ' ' ? '&nbsp;' : char;
          wordSpan.appendChild(charSpan);
        });
        element.appendChild(wordSpan);
        if (wordIndex < words.length - 1) {
          const space = document.createElement('span');
          space.classList.add('split-word');
          space.innerHTML = '&nbsp;';
          element.appendChild(space);
        }
      });
      return element.querySelectorAll('.split-char');
    }

    const textBlocksChunks = [];
    document.querySelectorAll('.text-block').forEach(block => {
      const targets = block.querySelectorAll('.split-target');
      let allChars = [];
      targets.forEach(t => {
        const chars = splitText(t);
        allChars = [...allChars, ...chars];
      });
      textBlocksChunks.push(allChars);
    });

    const cursorDot = document.getElementById('cursor-dot');
    const cursorRing = document.getElementById('cursor-ring');
    let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, vX: 0, vY: 0 };
    let cPos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let isHovering = false;
    let lastMouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

    if (!isMobile) {
      window.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });
      document.querySelectorAll('.magnetic').forEach(el => {
        el.addEventListener('mouseenter', () => { isHovering = true; cursorRing.style.borderColor = '#ff0077'; });
        el.addEventListener('mouseleave', () => { isHovering = false; cursorRing.style.borderColor = 'rgba(255,255,255,0.4)'; });
      });
    }

    const lenis = new Lenis({ smoothWheel: true, duration: 1.5, easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)) });
    lenis.on('scroll', ScrollTrigger.update);
    gsap.ticker.add((time) => { lenis.raf(time * 1000); updateCursor(); });
    gsap.ticker.lagSmoothing(0);

    function updateCursor() {
      if (isMobile) return;
      mouse.vX = mouse.x - lastMouse.x; mouse.vY = mouse.y - lastMouse.y;
      lastMouse.x = mouse.x; lastMouse.y = mouse.y;
      const velocity = Math.sqrt(mouse.vX * mouse.vX + mouse.vY * mouse.vY);
      const stretch = Math.min(velocity * 0.5, 20);
      const angle = Math.atan2(mouse.vY, mouse.vX) * 180 / Math.PI;
      cPos.x += (mouse.x - cPos.x) * 0.15; cPos.y += (mouse.y - cPos.y) * 0.15;
      cursorDot.style.transform = `translate(-50%, -50%) translate(${mouse.x}px, ${mouse.y}px)`;
      let ringSize = isHovering ? 60 : 40;
      cursorRing.style.width = `${ringSize + stretch}px`;
      cursorRing.style.height = `${ringSize - stretch * 0.2}px`;
      cursorRing.style.transform = `translate(-50%, -50%) translate(${cPos.x}px, ${cPos.y}px) rotate(${angle}deg)`;
    }

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050510, 0.025);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 20, 30);
    camera.rotation.set(-Math.PI / 8, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(pixelRatio);
    document.body.appendChild(renderer.domElement);

    const bgGeometry = new THREE.BufferGeometry();
    const bgVertices = new Float32Array([-1.0, -1.0, 0.0, 3.0, -1.0, 0.0, -1.0, 3.0, 0.0]);
    const bgUvs = new Float32Array([0.0, 0.0, 2.0, 0.0, 0.0, 2.0]);
    bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgVertices, 3));
    bgGeometry.setAttribute('uv', new THREE.BufferAttribute(bgUvs, 2));

    const bgUniforms = { uTime: { value: 0 }, uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }, uBgColor: { value: new THREE.Color(0x000000) } };

    const bgMaterial = new THREE.ShaderMaterial({
      uniforms: bgUniforms,
      vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
      fragmentShader: `
            uniform float uTime; uniform vec2 uResolution; uniform vec3 uBgColor; varying vec2 vUv;
            vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
            vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
            float snoise(vec3 v){ 
              const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
              vec3 i  = floor(v + dot(v, C.yyy) ); vec3 x0 = v - i + dot(i, C.xxx) ;
              vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g;
              vec3 i1 = min( g.xyz, l.zxy ); vec3 i2 = max( g.xyz, l.zxy );
              vec3 x1 = x0 - i1 + 1.0 * C.xxx; vec3 x2 = x0 - i2 + 2.0 * C.xxx; vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;
              i = mod(i, 289.0 ); 
              vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
              float n_ = 1.0/7.0; vec3 ns = n_ * D.wyz - D.xzx;
              vec4 j = p - 49.0 * floor(p * ns.z *ns.z); vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_ );
              vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy; vec4 h = 1.0 - abs(x) - abs(y);
              vec4 b0 = vec4( x.xy, y.xy ); vec4 b1 = vec4( x.zw, y.zw );
              vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0));
              vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
              vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w);
              vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
              p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
              vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
              m = m * m; return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
            float fbm(vec3 p) {
                float sum = 0.0; float amp = 1.0; float freq = 1.0;
                for(int i = 0; i < 3; i++) { sum += snoise(p * freq) * amp; amp *= 0.5; freq *= 2.0; }
                return sum;
            }
            vec4 raymarch(vec3 ro, vec3 rd) {
                float density = 0.0; vec3 col = vec3(0.0); float t = 0.0;
                for(int i = 0; i < 15; i++) {
                    vec3 p = ro + rd * t; vec3 dp = p; dp.z -= uTime * 0.2; 
                    float n = fbm(dp * 0.4); float d = smoothstep(0.0, 1.0, -abs(p.z) + 1.2 + n * 2.5); d = max(0.0, d);
                    if(d > 0.01) {
                        float alpha = (1.0 - density) * d * 0.15; density += alpha;
                        vec3 lavender = vec3(0.647, 0.580, 0.976); vec3 peach = vec3(1.0, 0.820, 0.663);
                        vec3 localCol = mix(lavender, peach, smoothstep(-0.5, 0.5, n));
                        col += localCol * alpha * 0.5; 
                    }
                    t += 0.2 + d * 0.1; if(density > 0.99 || t > 12.0) break;
                }
                return vec4(col, density);
            }
            void main() {
                vec2 uv = (vUv - 0.5) * 2.0; uv.x *= uResolution.x / uResolution.y;
                vec3 ro = vec3(0.0, 0.0, 4.0); vec3 rd = normalize(vec3(uv, -1.0));
                vec4 bgCol = vec4(0.02, 0.02, 0.06, 1.0); 
                vec4 res = raymarch(ro, rd);
                vec3 finalCol = mix(bgCol.rgb, res.rgb, res.a); gl_FragColor = vec4(finalCol, 1.0);
            }
        `,
      depthWrite: false, depthTest: false, transparent: true
    });

    const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial); bgMesh.frustumCulled = false; bgMesh.renderOrder = -100; scene.add(bgMesh);

    const ambientLight = new THREE.AmbientLight(0xffe5ec, 0.6); scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xa594f9, 1.5); dirLight.position.set(10, 20, 10); scene.add(dirLight);
    const oceanLight = new THREE.PointLight(0xffd1a9, 4.0, 100); oceanLight.position.set(0, -10, -50); scene.add(oceanLight);
    
    // Submarine Flashlight added directly to camera
    const subLight = new THREE.PointLight(0xffffff, 2.5, 150);
    camera.add(subLight);
    scene.add(camera);

    const allScenesGroup = new THREE.Group(); scene.add(allScenesGroup);

    const stoneMat = new THREE.MeshStandardMaterial({ color: 0x888899, roughness: 0.9, metalness: 0.1, flatShading: true });
    const fishMat = new THREE.MeshStandardMaterial({ color: 0xffb000, roughness: 0.3, metalness: 0.2, emissive: 0xff6600, emissiveIntensity: 0.2 });
    const coralMat = new THREE.MeshStandardMaterial({ color: 0xff88aa, roughness: 0.6, metalness: 0.1 });
    const glassMat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, transmission: 1.0, opacity: 1.0, roughness: 0.1, ior: 1.5, thickness: 0.5 });
    const darkStoneMat = new THREE.MeshStandardMaterial({ color: 0x1a1a24, roughness: 0.9, metalness: 0.3 });
    const pyramidMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.8, emissive: 0x886600, emissiveIntensity: 0.5, wireframe: isMobile });

    // Scene 1: The Galactic Peak
    const scene1Group = new THREE.Group();
    const pedestalGeo = new THREE.CylinderGeometry(15, 10, 5, 8);
    const pos = pedestalGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) { let v = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i)); if (v.y > 0) v.x += (Math.random() - 0.5) * 2; pos.setXYZ(i, v.x, v.y, v.z); }
    pedestalGeo.computeVertexNormals();
    const pedestal = new THREE.Mesh(pedestalGeo, stoneMat); pedestal.position.set(0, -2, 0); scene1Group.add(pedestal);
    const stairGeo = new THREE.BoxGeometry(8, 0.4, 3);
    for (let i = 0; i < 8; i++) { const step = new THREE.Mesh(stairGeo, stoneMat); step.position.set(Math.sin(i) * 5, -2 + i * -1.5, Math.cos(i) * 5); step.rotation.y = -i * 0.2; scene1Group.add(step); }
    allScenesGroup.add(scene1Group);

    // Scene 2: The Spiral Descent
    const scene2Group = new THREE.Group(); scene2Group.position.set(0, -35, 0);
    const floatingRockGeo = new THREE.IcosahedronGeometry(4, 1);
    const rpos = floatingRockGeo.attributes.position;
    for (let i = 0; i < rpos.count; i++) { rpos.setXYZ(i, rpos.getX(i) * (1 + Math.random() * 0.2), rpos.getY(i) * (1 + Math.random() * 0.2), rpos.getZ(i) * (1 + Math.random() * 0.2)); }
    floatingRockGeo.computeVertexNormals();
    for (let i = 0; i < 7; i++) { const rock = new THREE.Mesh(floatingRockGeo, stoneMat); rock.position.set((Math.random() - 0.5) * 40, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20); scene2Group.add(rock); }
    const fishies = []; const fishGeo = new THREE.ConeGeometry(0.5, 2, 4); fishGeo.rotateX(Math.PI / 2);
    for (let i = 0; i < 15; i++) { const fish = new THREE.Mesh(fishGeo, fishMat); fish.position.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30); scene2Group.add(fish); fishies.push({ mesh: fish, offset: Math.random() * Math.PI * 2, speed: 0.02 + Math.random() * 0.02 }); }
    allScenesGroup.add(scene2Group);

    // Scene 3: The Sacred Shell
    const scene3Group = new THREE.Group(); scene3Group.position.set(0, -90, -20);
    const shellGeo = new THREE.SphereGeometry(6, 16, 16, 0, Math.PI, 0, Math.PI / 2);
    const shellBottom = new THREE.Mesh(shellGeo, stoneMat); shellBottom.rotation.x = -Math.PI / 2;
    const shellTop = new THREE.Mesh(shellGeo, stoneMat); shellTop.rotation.x = -Math.PI / 4; shellTop.position.set(0, 1, -5);
    const pearl = new THREE.Mesh(new THREE.SphereGeometry(2, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.8, roughness: 0 })); pearl.position.set(0, 2, 0);
    scene3Group.add(shellBottom, shellTop, pearl); allScenesGroup.add(scene3Group);

    // Scene 4: The Marine Garden
    const scene4Group = new THREE.Group(); scene4Group.position.set(0, -150, -40);
    const weedGeo = new THREE.CylinderGeometry(0.2, 0.2, 20, 5); const weedMat = new THREE.MeshStandardMaterial({ color: 0x228855, roughness: 0.8 });
    const weeds = [];
    for (let i = 0; i < 40; i++) { const weed = new THREE.Mesh(weedGeo, weedMat); weed.position.set((Math.random() - 0.5) * 80, -5, (Math.random() - 0.5) * 40); scene4Group.add(weed); weeds.push({ mesh: weed, phase: Math.random() * Math.PI * 2 }); }
    allScenesGroup.add(scene4Group);

    // Scene 5: Deep Underwater Reef
    const scene5Group = new THREE.Group(); scene5Group.position.set(0, -230, -60);
    const obeliskGeo = new THREE.BoxGeometry(4, 60, 4);
    const obelisk1 = new THREE.Mesh(obeliskGeo, darkStoneMat); obelisk1.position.set(-25, 0, -10);
    const obelisk2 = new THREE.Mesh(obeliskGeo, darkStoneMat); obelisk2.position.set(30, -5, -20);
    scene5Group.add(obelisk1, obelisk2);
    const bubblesArr = []; const bubbleGeo = new THREE.SphereGeometry(2, 16, 16);
    for (let i = 0; i < 20; i++) { const b = new THREE.Mesh(bubbleGeo, glassMat); b.position.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 40, (Math.random() - 0.5) * 40); scene5Group.add(b); bubblesArr.push(b); }
    allScenesGroup.add(scene5Group);

    // Scene 6: The Golden Pyramid
    const scene6Group = new THREE.Group(); scene6Group.position.set(0, -320, -80);
    const mainPyramid = new THREE.Mesh(new THREE.ConeGeometry(30, 40, 4), pyramidMat); scene6Group.add(mainPyramid);
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x0a0a10, roughness: 1.0 })); floor.rotation.x = -Math.PI / 2; floor.position.y = -20; scene6Group.add(floor);
    allScenesGroup.add(scene6Group);

    function hideLoading() { const loaderUi = document.getElementById('loading'); if (loaderUi) { loaderUi.style.opacity = 0; setTimeout(() => loaderUi.remove(), 1000); } }
    setTimeout(hideLoading, 500);

    const fboSize = 128; const gpuCompute = new GPUComputationRenderer(fboSize, fboSize, renderer);
    if (isMobile) gpuCompute.setDataType(THREE.HalfFloatType);
    const heightmap0 = gpuCompute.createTexture();
    const pixels = heightmap0.image.data; for (let i = 0; i < pixels.length; i += 4) { pixels[i] = 0; pixels[i + 1] = 0; pixels[i + 2] = 0; pixels[i + 3] = 1; }
    
    const heightmapShader = `
        uniform vec2 mousePos; uniform float mouseSize; uniform float viscViscosity;
        void main() {
            vec2 uv = gl_FragCoord.xy / resolution.xy; vec2 texelSize = 1.0 / resolution.xy;
            float x0 = texture2D(heightmap, uv - vec2(texelSize.x, 0.0)).r; float x1 = texture2D(heightmap, uv + vec2(texelSize.x, 0.0)).r;
            float y0 = texture2D(heightmap, uv - vec2(0.0, texelSize.y)).r; float y1 = texture2D(heightmap, uv + vec2(0.0, texelSize.y)).r;
            vec4 currentState = texture2D(heightmap, uv); float currentHeight = currentState.r; float previousHeight = currentState.g; 
            float newHeight = ((x0 + x1 + y0 + y1) * 0.5) - previousHeight; newHeight *= 0.99; 
            float dist = distance(uv, mousePos); if(dist < mouseSize) { newHeight += (mouseSize - dist) * 0.1; }
            gl_FragColor = vec4(newHeight, currentHeight, 0.0, 1.0);
        }
    `;
    const heightmapVariable = gpuCompute.addVariable("heightmap", heightmapShader, heightmap0);
    gpuCompute.setVariableDependencies(heightmapVariable, [heightmapVariable]);
    heightmapVariable.material.uniforms.mousePos = { value: new THREE.Vector2(-1, -1) }; heightmapVariable.material.uniforms.mouseSize = { value: 0.03 };
    gpuCompute.init();

    const raycaster = new THREE.Raycaster(); const mouseContext = new THREE.Vector2(-1, -1);
    const oceanGeo = new THREE.PlaneGeometry(150, 150, oceanSegmentCount, oceanSegmentCount); oceanGeo.rotateX(-Math.PI / 2);
    const oceanUniforms = { uHeightmap: { value: null }, uColorDeep: { value: new THREE.Color('#000000') }, uColorShallow: { value: new THREE.Color('#3300aa') }, uTime: { value: 0 } };
    const oceanMat = new THREE.ShaderMaterial({
      uniforms: oceanUniforms,
      vertexShader: `uniform sampler2D uHeightmap; uniform float uTime; varying float vElevation; void main() { vec2 simUv = uv; vec4 heightData = texture2D(uHeightmap, simUv); float elevation = heightData.r * 15.0; elevation += sin(position.x * 0.05 + uTime * 0.5) * sin(position.z * 0.05 + uTime * 0.5) * 1.5; vec3 newPosition = position; newPosition.y += elevation; vElevation = elevation; gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); }`,
      fragmentShader: `uniform vec3 uColorDeep; uniform vec3 uColorShallow; varying float vElevation; void main() { float mixStrength = (vElevation + 1.0) * 0.3; mixStrength = clamp(mixStrength, 0.0, 1.0); vec3 color = mix(uColorDeep, uColorShallow, mixStrength); gl_FragColor = vec4(color, 1.0); }`
    });
    const ocean = new THREE.Mesh(oceanGeo, oceanMat); ocean.position.set(0, -10, -60); scene.add(ocean);
    const interactionPlane = new THREE.Mesh(new THREE.PlaneGeometry(150, 150), new THREE.MeshBasicMaterial({ visible: false })); interactionPlane.rotation.x = -Math.PI / 2; interactionPlane.position.copy(ocean.position); scene.add(interactionPlane);

    const godRayPass = new ShaderPass({
      uniforms: { tDiffuse: { value: null }, uTime: { value: 0 }, uColor: { value: new THREE.Color(0x7000ff) }, uIntensity: { value: 0.0 } },
      vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
      fragmentShader: `uniform sampler2D tDiffuse; uniform float uTime; uniform vec3 uColor; uniform float uIntensity; varying vec2 vUv; void main() { vec4 texel = texture2D(tDiffuse, vUv); float ray = sin(vUv.x * 20.0 + uTime) * sin(vUv.x * 10.0 - uTime * 0.5) * 0.5 + 0.5; float fade = smoothstep(0.0, 1.0, vUv.y); float grain = (fract(sin(dot(vUv + uTime, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * 0.05; vec3 finalColor = texel.rgb + uColor * ray * fade * uIntensity + grain; gl_FragColor = vec4(finalColor, texel.a); }`
    });
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    composer.addPass(godRayPass); 

    // =========================================
    // FIXED: The Full 6-Stage GSAP Timeline
    // =========================================
    const tl = gsap.timeline({ scrollTrigger: { trigger: "#scroll-container", start: "top top", end: "bottom bottom", scrub: 1.5 } });

    camera.position.set(0, 20, 30);
    
    // Phase 1 -> 2
    tl.to(camera.position, { x: 0, y: -35, z: 20, ease: "power1.inOut" }, 0.1);
    
    // Phase 2 -> 3
    tl.to(camera.position, { x: 0, y: -90, z: 10, ease: "power1.inOut" }, 0.25);
    
    // Phase 3 -> 4
    tl.to(camera.position, { x: 0, y: -150, z: -10, ease: "power2.inOut" }, 0.45);
    
    // Phase 4 -> 5
    tl.to(camera.position, { x: 0, y: -230, z: -30, ease: "power2.inOut" }, 0.65);
    
    // Phase 5 -> 6 (The Golden Pyramid)
    tl.to(camera.position, { x: 0, y: -310, z: -40, ease: "power3.out" }, 0.85);
    tl.to(camera.rotation, { x: Math.PI / 12, ease: "power1.inOut" }, 0.85);

    // Color Transitions underwater
    const colorTarget = { fogColor: new THREE.Color(0x050510) };
    tl.to(colorTarget.fogColor, { r: 0.1, g: 0.0, b: 0.3, onUpdate: () => scene.fog.color.copy(colorTarget.fogColor) }, 0.45);
    tl.to(godRayPass.uniforms.uIntensity, { value: 1.5 }, 0.45);

    // Text Animations
    gsap.to(textBlocksChunks[0], { y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out', scrollTrigger: { trigger: "#scroll-container", start: "0% top", end: "5% top", scrub: 1 } });
    tl.to(document.getElementById('text-1'), { opacity: 0, duration: 0.1 }, 0.08);

    document.getElementById('text-2').style.opacity = 1;
    gsap.fromTo(textBlocksChunks[1], { y: '110%' }, { y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out', scrollTrigger: { trigger: "#scroll-container", start: "12% top", end: "17% top", scrub: 1 } });
    tl.to(document.getElementById('text-2'), { opacity: 0, duration: 0.1 }, 0.22);

    document.getElementById('text-3').style.opacity = 1;
    gsap.fromTo(textBlocksChunks[2], { y: '110%' }, { y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out', scrollTrigger: { trigger: "#scroll-container", start: "28% top", end: "33% top", scrub: 1 } });
    tl.to(document.getElementById('text-3'), { opacity: 0, duration: 0.1 }, 0.4);

    document.getElementById('text-4').style.opacity = 1;
    gsap.fromTo(textBlocksChunks[3], { y: '110%' }, { y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out', scrollTrigger: { trigger: "#scroll-container", start: "45% top", end: "50% top", scrub: 1 } });
    tl.to(document.getElementById('text-4'), { opacity: 0, duration: 0.1 }, 0.6);

    document.getElementById('text-5').style.opacity = 1;
    gsap.fromTo(textBlocksChunks[4], { y: '110%' }, { y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out', scrollTrigger: { trigger: "#scroll-container", start: "62% top", end: "67% top", scrub: 1 } });
    tl.to(document.getElementById('text-5'), { opacity: 0, duration: 0.1 }, 0.8);

    document.getElementById('text-6').style.opacity = 1;
    gsap.fromTo(textBlocksChunks[5], { y: '110%' }, { y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out', scrollTrigger: { trigger: "#scroll-container", start: "82% top", end: "87% top", scrub: 1 } });

    //=========================================
    // 11. Render Loop
    //=========================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); 
    });

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate); const elapsedTime = clock.getElapsedTime();
      bgUniforms.uTime.value = elapsedTime;

      fishies.forEach(f => {
        f.mesh.position.x += Math.sin(elapsedTime * f.speed + f.offset) * 0.1;
        f.mesh.position.y += Math.cos(elapsedTime * f.speed + f.offset) * 0.05;
        f.mesh.rotation.x = Math.sin(elapsedTime * f.speed) * 0.2;
      });
      weeds.forEach(w => {
        w.mesh.rotation.z = Math.sin(elapsedTime + w.phase) * 0.1;
      });

      if (camera.position.z < -20 && !isMobile) {
        raycaster.setFromCamera(mouseContext, camera); const intersects = raycaster.intersectObject(interactionPlane);
        if (intersects.length > 0) heightmapVariable.material.uniforms.mousePos.value.set(intersects[0].uv.x, intersects[0].uv.y);
        else heightmapVariable.material.uniforms.mousePos.value.set(-1, -1);
      } else heightmapVariable.material.uniforms.mousePos.value.set(-1, -1);

      gpuCompute.compute();
      oceanUniforms.uHeightmap.value = gpuCompute.getCurrentRenderTarget(heightmapVariable).texture;
      oceanUniforms.uTime.value = elapsedTime;

      if (composer) godRayPass.uniforms.uTime.value = elapsedTime;
      composer.render();
    }
    animate();
  </script>
</body>
</html>
