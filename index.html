<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Organimo R&D - The Descent (FBO physics)</title>
  <!-- Preload fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,600&family=Space+Grotesk:wght@400;700&display=swap"
    rel="stylesheet">
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      background: #000000;
      color: #ffffff;
      font-family: 'Space Grotesk', sans-serif;
      overflow-x: hidden;
      width: 100%;
      cursor: none;
      /* Hide default cursor */
    }

    /* Custom Magnetic Cursor */
    #cursor-dot,
    #cursor-ring {
      position: fixed;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10000;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      will-change: transform, width, height;
    }

    #cursor-dot {
      width: 6px;
      height: 6px;
      background-color: #fff;
      mix-blend-mode: exclusion;
    }

    #cursor-ring {
      width: 40px;
      height: 40px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      transition: border-color 0.3s ease;
    }

    .magnetic {
      /* apply this class to element that should attract cursor */
      display: inline-block;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
    }

    #header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 2.5rem;
      display: flex;
      justify-content: space-between;
      box-sizing: border-box;
      mix-blend-mode: exclusion;
      z-index: 100;
      pointer-events: none;
    }

    .logo {
      font-family: 'Playfair Display', serif;
      font-style: italic;
      font-size: 1.8rem;
      letter-spacing: 1px;
      pointer-events: auto;
      cursor: none;
    }

    .nav {
      font-size: 1rem;
      letter-spacing: 4px;
      text-transform: uppercase;
      pointer-events: auto;
      cursor: none;
    }

    #scroll-container {
      height: 500vh;
      width: 100vw;
      position: relative;
    }

    .story-text {
      position: fixed;
      left: 10vw;
      top: 50vh;
      transform: translateY(-50%);
      max-width: 500px;
      pointer-events: none;
      mix-blend-mode: exclusion;
    }

    /* Text Splitting Setup */
    .split-word {
      display: inline-block;
      overflow: hidden;
      /* Hide the character before it slides up */
      vertical-align: top;
    }

    .split-char {
      display: inline-block;
      transform: translateY(110%);
      /* Start hidden down */
      will-change: transform;
    }

    h1 {
      font-family: 'Playfair Display', serif;
      font-size: 4rem;
      font-style: italic;
      margin: 0 0 1rem 0;
      letter-spacing: 1px;
      font-weight: 600;
      line-height: 1.1;
    }

    p {
      font-size: 1.2rem;
      line-height: 1.6;
      margin: 0;
      opacity: 0.8;
      font-weight: 400;
    }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 999;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1.5rem;
      letter-spacing: 4px;
      transition: opacity 1s ease;
      cursor: none;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2.5rem;
      }

      .story-text {
        left: 5vw;
        right: 5vw;
        max-width: none;
        text-align: center !important;
      }

      #cursor-dot,
      #cursor-ring {
        display: none;
      }

      /* Disable custom cursor on mobile */
    }
  </style>
</head>

<body>

  <!-- Custom Cursor Elements -->
  <div id="cursor-dot"></div>
  <div id="cursor-ring"></div>

  <div id="loading">LOADING EXPERIENCE...</div>

  <header id="header">
    <div class="logo magnetic">Organimo R&D</div>
    <div class="nav magnetic">The Descent</div>
  </header>

  <div id="scroll-container">
    <div class="story-text text-block" id="text-1">
      <h1 class="split-target">The Architecture</h1>
      <p class="split-target">Descending into the procedural depths of the digital environment.</p>
    </div>
    <div class="story-text text-block" id="text-2" style="left: auto; right: 10vw; text-align: right;">
      <h1 class="split-target">Fluid Memory</h1>
      <p class="split-target">Artifacts of the past float through the synthetic atmosphere, bending as you pass.</p>
    </div>
    <div class="story-text text-block" id="text-3">
      <h1 class="split-target">The Deep</h1>
      <p class="split-target">A seamless ocean of simulated mathematical noise reacting to light.</p>
    </div>
  </div>

  <!-- Import Maps -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "gsap": "https://unpkg.com/gsap@3.12.5/index.js",
      "gsap/ScrollTrigger": "https://unpkg.com/gsap@3.12.5/ScrollTrigger.js",
      "@studio-freight/lenis": "https://unpkg.com/@studio-freight/lenis@1.0.42/dist/lenis.mjs"
    }
  }
</script>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
    import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
    import gsap from 'gsap';
    import ScrollTrigger from 'gsap/ScrollTrigger';
    import Lenis from '@studio-freight/lenis';

    gsap.registerPlugin(ScrollTrigger);

    //=========================================
    // 0. Performance & Device Detection
    //=========================================
    const isMobile = window.innerWidth <= 768 || /Mobi|Android/i.test(navigator.userAgent);
    const pixelRatio = isMobile ? 1 : Math.min(window.devicePixelRatio, 2);
    const useBloom = !isMobile;
    const oceanSegmentCount = isMobile ? 128 : 256; // Need reasonable segments for FBO ripples

    //=========================================
    // 1. Text Splitting Utility (Typography)
    //=========================================
    function splitText(element) {
      const text = element.innerText;
      element.innerHTML = '';
      const words = text.split(' ');
      words.forEach((word, wordIndex) => {
        const wordSpan = document.createElement('span');
        wordSpan.classList.add('split-word');
        word.split('').forEach((char) => {
          const charSpan = document.createElement('span');
          charSpan.classList.add('split-char');
          charSpan.innerHTML = char === ' ' ? '&nbsp;' : char;
          wordSpan.appendChild(charSpan);
        });
        element.appendChild(wordSpan);
        // Add space between words
        if (wordIndex < words.length - 1) {
          const space = document.createElement('span');
          space.classList.add('split-word');
          space.innerHTML = '&nbsp;';
          element.appendChild(space);
        }
      });
      return element.querySelectorAll('.split-char');
    }

    // Split all targets initially
    const textBlocksChunks = [];
    document.querySelectorAll('.text-block').forEach(block => {
      const targets = block.querySelectorAll('.split-target');
      let allChars = [];
      targets.forEach(t => {
        const chars = splitText(t);
        allChars = [...allChars, ...chars];
      });
      textBlocksChunks.push(allChars);
    });

    //=========================================
    // 2. Custom Magnetic Cursor
    //=========================================
    const cursorDot = document.getElementById('cursor-dot');
    const cursorRing = document.getElementById('cursor-ring');
    let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, vX: 0, vY: 0 };
    let cPos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let isHovering = false;
    let lastMouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

    if (!isMobile) {
      window.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      document.querySelectorAll('.magnetic').forEach(el => {
        el.addEventListener('mouseenter', () => { isHovering = true; cursorRing.style.borderColor = '#ff0077'; });
        el.addEventListener('mouseleave', () => { isHovering = false; cursorRing.style.borderColor = 'rgba(255,255,255,0.4)'; });
      });
    }

    //=========================================
    // 3. Core Three.js Setups
    //=========================================
    const lenis = new Lenis({
      smoothWheel: true,
      duration: 1.5,
      easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t))
    });

    lenis.on('scroll', ScrollTrigger.update);
    gsap.ticker.add((time) => {
      lenis.raf(time * 1000);
      updateCursor();
    });
    gsap.ticker.lagSmoothing(0);

    function updateCursor() {
      if (isMobile) return;

      // Calculate velocity for stretching
      mouse.vX = mouse.x - lastMouse.x;
      mouse.vY = mouse.y - lastMouse.y;
      lastMouse.x = mouse.x;
      lastMouse.y = mouse.y;

      const velocity = Math.sqrt(mouse.vX * mouse.vX + mouse.vY * mouse.vY);
      const stretch = Math.min(velocity * 0.5, 20); // Cap stretch

      // Calculate angle for squish/stretch
      const angle = Math.atan2(mouse.vY, mouse.vX) * 180 / Math.PI;

      cPos.x += (mouse.x - cPos.x) * 0.15;
      cPos.y += (mouse.y - cPos.y) * 0.15;

      cursorDot.style.transform = `translate(-50%, -50%) translate(${mouse.x}px, ${mouse.y}px)`;

      let ringSize = isHovering ? 60 : 40;
      cursorRing.style.width = `${ringSize + stretch}px`;
      cursorRing.style.height = `${ringSize - stretch * 0.2}px`;
      cursorRing.style.transform = `translate(-50%, -50%) translate(${cPos.x}px, ${cPos.y}px) rotate(${angle}deg)`;
    }

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 20, 30);
    camera.rotation.set(-Math.PI / 8, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: !useBloom, alpha: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(pixelRatio);
    document.body.appendChild(renderer.domElement);

    //=========================================
    // 4. Asset Compression Pipeline (DRACO & KTX2)
    //=========================================
    const dracoLoader = new DRACOLoader();
    // Point to Draco decoder files (CDN or local path)
    dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/gltf/');

    const ktx2Loader = new KTX2Loader();
    ktx2Loader.setTranscoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/');
    ktx2Loader.detectSupport(renderer);

    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);
    gltfLoader.setKTX2Loader(ktx2Loader);

    // Architecture setup
    const architectureGroup = new THREE.Group();
    scene.add(architectureGroup);

    // Procedural Fallback Staircase
    const stairGeo = new THREE.BoxGeometry(10, 0.5, 2);
    const stairMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.2 });
    for (let i = 0; i < 40; i++) {
      const step = new THREE.Mesh(stairGeo, stairMat);
      step.position.set(0, 15 - i * 0.5, 20 - i * 2);
      architectureGroup.add(step);
    }

    // <-- ATTACH YOUR COMPRESSED GLB MODEL HERE -->
    /*
    gltfLoader.load('path_to_compressed_staircase.glb', (gltf) => {
        architectureGroup.clear();
        const model = gltf.scene;
        architectureGroup.add(model);
        hideLoading();
    });
    */

    function hideLoading() {
      const loaderUi = document.getElementById('loading');
      if (loaderUi) {
        loaderUi.style.opacity = 0;
        setTimeout(() => loaderUi.remove(), 1000);
      }
    }
    setTimeout(hideLoading, 500); // Fallback init

    //=========================================
    // 5. Light setup
    //=========================================
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0x7000ff, 2.0);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    const oceanLight = new THREE.PointLight(0x0033ff, 5.0, 100);
    oceanLight.position.set(0, -10, -50);
    scene.add(oceanLight);

    //=========================================
    // 6. GPGPU / FBO Physics for Ocean Ripples
    //=========================================
    // We use a simplified 2D heightmap simulation via GPUComputationRenderer
    const fboSize = 256; // Simulation grid resolution
    const gpuCompute = new GPUComputationRenderer(fboSize, fboSize, renderer);
    if (isMobile) gpuCompute.setDataType(THREE.HalfFloatType);

    const heightmap0 = gpuCompute.createTexture();
    fillTexture(heightmap0);

    const heightmapShader = `
        uniform vec2 mousePos;
        uniform float mouseSize;
        uniform float viscViscosity;

        void main() {
            vec2 uv = gl_FragCoord.xy / resolution.xy;
            
            // Standard ripple physics: read neighbors
            vec2 texelSize = 1.0 / resolution.xy;
            
            float x0 = texture2D(heightmap, uv - vec2(texelSize.x, 0.0)).r;
            float x1 = texture2D(heightmap, uv + vec2(texelSize.x, 0.0)).r;
            float y0 = texture2D(heightmap, uv - vec2(0.0, texelSize.y)).r;
            float y1 = texture2D(heightmap, uv + vec2(0.0, texelSize.y)).r;
            
            // Current state
            vec4 currentState = texture2D(heightmap, uv);
            float currentHeight = currentState.r;
            float previousHeight = currentState.g; // We store previous state in G channel
            
            // Wave equation computation
            float newHeight = ((x0 + x1 + y0 + y1) * 0.5) - previousHeight;
            newHeight *= 0.99; // Damping (viscosity)
            
            // Mouse interaction (add energy)
            float dist = distance(uv, mousePos);
            if(dist < mouseSize) {
                newHeight += (mouseSize - dist) * 0.1; // Add displacement
            }
            
            // Save state: R=NewHeight, G=CurrentHeight (becomes previous next frame)
            gl_FragColor = vec4(newHeight, currentHeight, 0.0, 1.0);
        }
    `;

    const heightmapVariable = gpuCompute.addVariable("heightmap", heightmapShader, heightmap0);
    gpuCompute.setVariableDependencies(heightmapVariable, [heightmapVariable]);

    heightmapVariable.material.uniforms.mousePos = { value: new THREE.Vector2(-1, -1) };
    heightmapVariable.material.uniforms.mouseSize = { value: 0.03 }; // Radius of ripple

    const error = gpuCompute.init();
    if (error !== null) console.error(error);

    function fillTexture(texture) {
      const pixels = texture.image.data;
      for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 0;
        pixels[i + 1] = 0;
        pixels[i + 2] = 0;
        pixels[i + 3] = 1;
      }
    }

    // Raycaster for physics interaction
    const raycaster = new THREE.Raycaster();
    const mouseContext = new THREE.Vector2(-1, -1);

    // Ocean Geometry
    const oceanGeo = new THREE.PlaneGeometry(150, 150, oceanSegmentCount, oceanSegmentCount);
    oceanGeo.rotateX(-Math.PI / 2);

    const oceanUniforms = {
      uHeightmap: { value: null }, // Fed by GPGPU
      uColorDeep: { value: new THREE.Color('#001133') },
      uColorShallow: { value: new THREE.Color('#4400aa') },
      uTime: { value: 0 }
    };

    const oceanMat = new THREE.ShaderMaterial({
      uniforms: oceanUniforms,
      vertexShader: `
            uniform sampler2D uHeightmap;
            uniform float uTime;
            varying float vElevation;

            void main() {
                // UV mapped from 0 to 1 over the plane
                vec2 simUv = uv; 
                vec4 heightData = texture2D(uHeightmap, simUv);
                
                // Read R channel for height
                float elevation = heightData.r * 15.0; // scale displacement
                
                // Add underlying slow ocean swell base
                elevation += sin(position.x * 0.05 + uTime * 0.5) * sin(position.z * 0.05 + uTime * 0.5) * 1.5;

                vec3 newPosition = position;
                newPosition.y += elevation;
                vElevation = elevation;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `,
      fragmentShader: `
            uniform vec3 uColorDeep;
            uniform vec3 uColorShallow;
            varying float vElevation;

            void main() {
                // Mix color based on elevation
                float mixStrength = (vElevation + 1.0) * 0.3; 
                mixStrength = clamp(mixStrength, 0.0, 1.0);
                
                vec3 color = mix(uColorDeep, uColorShallow, mixStrength);
                gl_FragColor = vec4(color, 1.0);
            }
        `,
      // wireframe: true // Helpful for debugging displacement
    });

    const ocean = new THREE.Mesh(oceanGeo, oceanMat);
    ocean.position.set(0, -10, -60);
    scene.add(ocean);

    // Invisible plane for raycasting ripples (matches ocean pos exactly)
    const interactionPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(150, 150),
      new THREE.MeshBasicMaterial({ visible: false })
    );
    interactionPlane.rotation.x = -Math.PI / 2;
    interactionPlane.position.copy(ocean.position);
    scene.add(interactionPlane);

    if (!isMobile) {
      window.addEventListener('mousemove', (e) => {
        mouseContext.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouseContext.y = -(e.clientY / window.innerHeight) * 2 + 1;
      });
    }

    //=========================================
    // 7. Post-Processing Context
    //=========================================
    let composer;
    if (useBloom) {
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.1);
      composer.addPass(bloomPass);
    }

    //=========================================
    // 8. GSAP ScrollTrigger Master Journey 
    //=========================================
    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: "#scroll-container",
        start: "top top",
        end: "bottom bottom",
        scrub: 1.5
      }
    });

    // Camera Motion
    tl.to(camera.position, { x: 0, y: -5, z: -50, ease: "power2.inOut" }, 0);
    tl.to(camera.rotation, { x: 0.1, ease: "power1.inOut" }, 0.2);

    // Staggered Character Animation Timings
    // Text 1 appears early, hides early
    gsap.to(textBlocksChunks[0], {
      y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out',
      scrollTrigger: {
        trigger: "#scroll-container", start: "1% top", end: "10% top", scrub: 1
      }
    });
    tl.to(document.getElementById('text-1'), { opacity: 0, duration: 0.1 }, 0.2);

    // Text 2 appearing
    document.getElementById('text-2').style.opacity = 1; // Base opacity 1, hidden by Y transform
    gsap.fromTo(textBlocksChunks[1], { y: '110%' }, {
      y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out',
      scrollTrigger: {
        trigger: "#scroll-container", start: "30% top", end: "40% top", scrub: 1
      }
    });
    tl.to(document.getElementById('text-2'), { opacity: 0, duration: 0.1 }, 0.6);

    // Text 3 appearing
    document.getElementById('text-3').style.opacity = 1;
    gsap.fromTo(textBlocksChunks[2], { y: '110%' }, {
      y: '0%', duration: 1, stagger: 0.02, ease: 'power3.out',
      scrollTrigger: {
        trigger: "#scroll-container", start: "70% top", end: "85% top", scrub: 1
      }
    });

    //=========================================
    // 9. Render Loop
    //=========================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (useBloom) composer.setSize(window.innerWidth, window.innerHeight);
    });

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const elapsedTime = clock.getElapsedTime();

      // 1. Physics Raycasting Update
      // Only run raycaster when camera is close enough to the ocean to make sense
      if (camera.position.z < -20 && !isMobile) {
        raycaster.setFromCamera(mouseContext, camera);
        const intersects = raycaster.intersectObject(interactionPlane);

        if (intersects.length > 0) {
          // UVs of interaction plane map to 0-1 for the FBO texture
          const uv = intersects[0].uv;
          heightmapVariable.material.uniforms.mousePos.value.set(uv.x, uv.y);
        } else {
          heightmapVariable.material.uniforms.mousePos.value.set(-1, -1);
        }
      } else {
        heightmapVariable.material.uniforms.mousePos.value.set(-1, -1);
      }

      // 2. Compute FBO Physics
      gpuCompute.compute();

      // 3. Feed result back to Ocean Shader
      oceanUniforms.uHeightmap.value = gpuCompute.getCurrentRenderTarget(heightmapVariable).texture;
      oceanUniforms.uTime.value = elapsedTime;

      // 4. Render Scene
      if (useBloom) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

    animate();
  </script>

</body>

</html>
